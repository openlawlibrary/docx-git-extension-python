#!/usr/bin/env python3
"""
Create a DOCX of approximately a target size using either python-docx or Aspose.Words,
by embedding incompressible images, with a one-character marker you can toggle (e.g., 3 -> 4)
for minimal content diffs.

USAGE
-----
  python create_docx.py <engine> --out big.docx --target-mib 10 --tolerance-kb 100 --seed 123 --marker 3 \
      [--image path.png]

where <engine> is one of: python-docx | aspose

Dependencies
------------
- python-docx path:
    pip install python-docx pillow
- aspose path:
    pip install aspose-words pillow
"""
from __future__ import annotations

import argparse
import os
import random
import tempfile
from datetime import datetime, timezone
from pathlib import Path
import zipfile

# Pillow for generating filler images
from PIL import Image

# ----------------------------
# Shared helpers (both engines)
# ----------------------------
FIXED_TIME = datetime(2020, 1, 1, 12, 0, 0, tzinfo=timezone.utc)
FIXED_DOS_TIME = (2020, 1, 1, 0, 0, 0)  # year, mon, day, hour, min, sec

def make_noise_png(dst: Path, width: int, height: int, rng: random.Random) -> int:
    """
    Create a random RGB PNG with essentially incompressible content.
    Use PNG compress_level=0 to avoid zlib squeezing inside the PNG itself.
    Returns the file size in bytes.
    """
    img = Image.new("RGB", (width, height))
    raw = bytes(rng.getrandbits(8) for _ in range(width * height * 3))
    img.frombytes(raw)
    img.save(dst, format="PNG", compress_level=0)
    return dst.stat().st_size

# -----------------
# python-docx path
# -----------------
def make_python_docx(out_path: Path, image_path: str | None, target_mib: float,
                     tolerance_kb: int, seed: int | None, marker: str) -> None:
    try:
        from docx import Document
        from docx.shared import Pt, Inches
        from docx.enum.text import WD_ALIGN_PARAGRAPH
        from docx.oxml.ns import qn
    except Exception as e:
        raise SystemExit("python-docx is not installed. Please 'pip install python-docx'.") from e

    rng = random.Random(seed)
    doc = Document()

    # --- Base content ---
    doc.add_heading("Example DOCX generated by python-docx", level=0)

    p = doc.add_paragraph()
    p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
    r = p.add_run("This document demonstrates basic ")
    r.font.size = Pt(11)
    p.add_run("python-docx").bold = True
    p.add_run(" features: headings, styled text, lists, tables")
    p.add_run(", and an optional image. ").italic = True

    p2 = doc.add_paragraph("You can control font size programmatically. ")
    r2 = p2.add_run("This run is 14pt.")
    r2.font.size = Pt(14)

    # Lists
    doc.add_paragraph("First bullet item", style="List Bullet")
    doc.add_paragraph("Second bullet item", style="List Bullet")
    doc.add_paragraph("Third bullet item", style="List Bullet")

    doc.add_paragraph("First numbered item", style="List Number")
    doc.add_paragraph("Second numbered item", style="List Number")
    doc.add_paragraph("Third numbered item", style="List Number")

    # Table
    table = doc.add_table(rows=3, cols=3, style="Table Grid")
    headers = ["Column A", "Column B", "Column C"]
    for j, text in enumerate(headers):
        cell = table.rows[0].cells[j]
        cell.text = text
        for run in cell.paragraphs[0].runs:
            run.bold = True
    table.cell(1, 0).text = "A2"
    table.cell(1, 1).text = "B2"
    table.cell(1, 2).text = "C2"
    table.cell(2, 0).text = "A3"
    table.cell(2, 1).text = "B3"
    table.cell(2, 2).text = "C3"

    # One-character marker
    mp = doc.add_paragraph()
    mp.add_run("Marker: ")
    mp.add_run(marker)

    # Optional image
    if image_path and os.path.exists(image_path):
        doc.add_page_break()
        doc.add_heading("Image", level=1)
        doc.add_paragraph("Below is an image inserted at 3 inches width:")
        doc.add_picture(image_path, width=Inches(3))

    # Core props (fixed timestamps for stability)
    cp = doc.core_properties
    cp.title = "python-docx example"
    cp.subject = "Demo"
    cp.author = "Example Author"
    cp.keywords = "python, docx, demo"
    cp.created = FIXED_TIME
    cp.modified = FIXED_TIME
    cp.last_printed = FIXED_TIME

    # Default font
    styles = doc.styles
    try:
        normal = styles["Normal"]
        normal.font.name = "Calibri"
        normal.element.rPr.rFonts.set(qn("w:eastAsia"), "Calibri")
    except Exception:
        pass

    # --- Grow to size by embedding near-incompressible PNGs ---
    target_bytes = int(target_mib * (1024**2))
    tolerance_bytes = int(tolerance_kb * 1024)

    # Write initial base doc to measure its size.
    doc.save(out_path)
    base_size = out_path.stat().st_size

    if base_size < target_bytes - tolerance_bytes:
        remaining = target_bytes - base_size
        tile_candidates = [2048, 1536, 1024, 768, 512, 256, 128, 64]
        with tempfile.TemporaryDirectory() as tmpd:
            tmpdir = Path(tmpd)
            measured_tile_sizes: dict[int, int] = {}

            for side in tile_candidates:
                probe = tmpdir / f"probe_{side}.png"
                approx_png = make_noise_png(probe, side, side, rng)
                measured_tile_sizes[side] = approx_png
                try:
                    probe.unlink()
                except FileNotFoundError:
                    pass

                if approx_png <= 0:
                    continue

                count = max(0, int((remaining * 0.95) // approx_png))
                count = min(count, 12)

                from docx.shared import Inches as _Inches  # local alias
                for i in range(count):
                    img_path = tmpdir / f"noise_{side}_{i}.png"
                    size_bytes = make_noise_png(img_path, side, side, rng)
                    doc.add_picture(str(img_path), width=_Inches(1.0))
                    remaining -= size_bytes
                    if remaining <= tolerance_bytes:
                        doc.save(out_path)
                        break

            # Fine fill with smallest tiles
            side = 64
            while remaining > tolerance_bytes:
                img_path = tmpdir / f"noise_{side}_{rng.randrange(1_000_000)}.png"
                size_bytes = make_noise_png(img_path, side, side, rng)
                doc.add_picture(str(img_path), width=_Inches(0.5))
                remaining -= size_bytes
            doc.save(out_path)

# -------------
# Aspose path
# -------------
def make_aspose_docx(out_path: Path, image_path: str | None, target_mib: float,
                     tolerance_kb: int, seed: int | None, marker: str) -> None:
    try:
        import aspose.words as aw  # type: ignore
    except Exception as e:
        raise SystemExit("Aspose.Words for Python is not installed. Please 'pip install aspose-words'.") from e

    rng = random.Random(seed)
    doc = aw.Document()
    builder = aw.DocumentBuilder(doc)

    # Base font
    builder.font.name = "Calibri"
    builder.font.size = 11

    # Heading
    builder.paragraph_format.style_identifier = aw.StyleIdentifier.HEADING1
    builder.writeln("Example DOCX generated by Aspose.Words")

    # Body text with styling
    builder.paragraph_format.clear_formatting()
    builder.write("This document demonstrates basic ")
    builder.font.bold = True
    builder.write("Aspose.Words")
    builder.font.bold = False
    builder.write(" features: headings, styled text, lists, tables")
    builder.font.italic = True
    builder.write(", and an optional image. ")
    builder.font.italic = False
    builder.writeln("")

    builder.write("You can control font size programmatically. ")
    builder.font.size = 14
    builder.write("This run is 14pt.")
    builder.font.size = 11
    builder.writeln("")

    # Bulleted list
    builder.list_format.apply_bullet_default()
    builder.writeln("First bullet item")
    builder.writeln("Second bullet item")
    builder.writeln("Third bullet item")
    builder.list_format.remove_numbers()

    # Numbered list
    builder.list_format.apply_number_default()
    builder.writeln("First numbered item")
    builder.writeln("Second numbered item")
    builder.writeln("Third numbered item")
    builder.list_format.remove_numbers()

    # Table 3x3
    builder.start_table()
    # Header row (bold)
    for text in ["Column A", "Column B", "Column C"]:
        builder.insert_cell()
        builder.font.bold = True
        builder.write(text)
        builder.font.bold = False
    builder.end_row()

    for row in [["A2", "B2", "C2"], ["A3", "B3", "C3"]]:
        for cell_text in row:
            builder.insert_cell()
            builder.write(cell_text)
        builder.end_row()
    table = builder.end_table()

    # Marker
    builder.writeln("")
    builder.write("Marker: ")
    builder.write(marker)
    builder.writeln("")

    # Optional image
    if image_path and os.path.exists(image_path):
        builder.insert_break(aw.BreakType.PAGE_BREAK)
        builder.paragraph_format.style_identifier = aw.StyleIdentifier.HEADING2
        builder.writeln("Image")
        builder.paragraph_format.clear_formatting()
        # Insert at approx 3 inches width, proportional height
        try:
            width_pts = aw.ConvertUtil.inch_to_point(3.0)
        except Exception:
            width_pts = 216.0  # 3in * 72pt/in fallback
        builder.insert_image(image_path, width_pts, 0)

    # Core props
    props = doc.built_in_document_properties
    props.title = "aspose example"
    props.subject = "Demo"
    props.author = "Example Author"
    props.keywords = "python, aspose, docx, demo"
    try:
        props.created_time = FIXED_TIME
        props.last_saved_time = FIXED_TIME
        props.last_printed = FIXED_TIME
    except Exception:
        # Some environments may not accept Python datetime; ignore if so.
        pass

    # Save initial to measure size
    doc.save(str(out_path))
    base_size = out_path.stat().st_size

    # Grow to size with filler images (estimate by PNG sizes)
    target_bytes = int(target_mib * (1024**2))
    tolerance_bytes = int(tolerance_kb * 1024)

    if base_size < target_bytes - tolerance_bytes:
        remaining = target_bytes - base_size
        tile_candidates = [2048, 1536, 1024, 768, 512, 256, 128, 64]
        with tempfile.TemporaryDirectory() as tmpd:
            tmpdir = Path(tmpd)
            measured_tile_sizes: dict[int, int] = {}

            for side in tile_candidates:
                probe = tmpdir / f"probe_{side}.png"
                approx_png = make_noise_png(probe, side, side, rng)
                measured_tile_sizes[side] = approx_png
                try:
                    probe.unlink()
                except FileNotFoundError:
                    pass

                if approx_png <= 0:
                    continue

                count = max(0, int((remaining * 0.95) // approx_png))
                count = min(count, 12)

                for i in range(count):
                    img_path = tmpdir / f"noise_{side}_{i}.png"
                    size_bytes = make_noise_png(img_path, side, side, rng)
                    # Insert image (approx 1 inch width for these tiles)
                    try:
                        width_pts_small = aw.ConvertUtil.inch_to_point(1.0)
                    except Exception:
                        width_pts_small = 72.0
                    builder.insert_image(str(img_path), width_pts_small, 0)
                    remaining -= size_bytes
                    if remaining <= tolerance_bytes:
                        doc.save(str(out_path))
                        break

            # Fine fill with smallest tiles
            side = 64
            while remaining > tolerance_bytes:
                img_path = tmpdir / f"noise_{side}_{rng.randrange(1_000_000)}.png"
                size_bytes = make_noise_png(img_path, side, side, rng)
                try:
                    width_pts_tiny = aw.ConvertUtil.inch_to_point(0.5)
                except Exception:
                    width_pts_tiny = 36.0
                builder.insert_image(str(img_path), width_pts_tiny, 0)
                remaining -= size_bytes

            doc.save(str(out_path))

# -------------
# Main program
# -------------
def main():
    ap = argparse.ArgumentParser(description="Create a DOCX using either python-docx or Aspose, with size targeting.")
    ap.add_argument("engine", choices=["python-docx", "aspose"], help="Document creation engine to use.")
    ap.add_argument("--out", default="example.docx", help="Output DOCX path")
    ap.add_argument("--image", default=None, help="Optional image path to insert")
    ap.add_argument("--target-mib", type=float, default=10.0, help="Approximate target size in MiB (default: 10)")
    ap.add_argument("--tolerance-kb", type=int, default=100, help="Acceptable +/- range around target in KiB (default: 100)")
    ap.add_argument("--seed", type=int, default=None, help="Seed for reproducible filler images (optional)")
    ap.add_argument("--marker", default="3", help="Single character/text to embed for a minimal visible change (default: 3)")
    args = ap.parse_args()

    out_path = Path(args.out)

    if args.engine == "python-docx":
        make_python_docx(
            out_path=out_path,
            image_path=args.image,
            target_mib=args.target_mib,
            tolerance_kb=args.tolerance_kb,
            seed=args.seed,
            marker=args.marker,
        )
    else:  # "aspose"
        make_aspose_docx(
            out_path=out_path,
            image_path=args.image,
            target_mib=args.target_mib,
            tolerance_kb=args.tolerance_kb,
            seed=args.seed,
            marker=args.marker,
        )

    print(f"Wrote: {out_path.resolve()}")


if __name__ == "__main__":
    main()
